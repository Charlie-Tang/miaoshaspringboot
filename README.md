# miaoshaspringboot
springboot-seckill

准备工作：springboot整合ssm等
我们在搭建一个springboot项目的时候首先需要导入插件或者使用start.spring.io去创建，其实两者并没有太大区别，都是使用同样的方法创建
项目。需要了解的是：在2.0.0后的版本所使用的是Netty服务器，而之前默认使用的都是Tomcat服务器。
springboot由于集成了spring全家桶的各个包，所以特别好用，在pom.xml中就可直接导入相关jar。而相关参数配置也摒弃掉了之前项目的各种xml参数
配置，而直接使用application.properties去配置各种参数，极大提高了项目的可维护性和入门难度。
同时，我们dao层的配置可以直接通过配置mybatis-generator.xml来在maven中直接调用，通过该方法，使得我们创建dao层和domain所使用的时间大大降低，
通过其创建的各种mapper中的方法，使得我们service层能够直接调用相关方法。

整体思路:

首先项目其实是定义了Error类和CommonReturnType类，通过前者去抛出和定义各种异常，而后者则是对于使用Ajax获取各类数据和跳转界面
提供了帮助。

用户模块：
（记录：application/x-www-form-urlencoded和application/json的区别：前者是通过Map去存储我们的各个参数的，
所以可以通过@RequestParam去获取前端参数，而后者则无法使用该注解去获取参数！）
用户获取：
然后通过定义了/get的测试用例来了解在各个数据层面去展示给用户不同的部分。
比如我们首先是定义用户的各种属性，由于保密原则我们知道密码和这些属性是不能放在同一张表中的，所以分表，给用户密码和用户其他属性做链接，
并给密码做BASE64位加密  MD5盐值加密应该也是同理。
而后我们需要知道的是：需要将这两张不同表的数据，放在一个Model层面的数据模型中，我们可以通过BeanUtils.copyProperties去复制这些数据，
但是需要保证字段是一致的，如果不一致的话可通过打断点去浏览每段数据所带数据是否一致。
同理我们暴露在View层的数据应该也是由我们自己定义的，即VO数据，此时我们需要将数据再次转换成一个可供查看的类型。

用户登录：
而后我所做的测试是登录层面的，通过电话和密码登录，（参数校验）永远是必不可少的，经过校验非空后，通过电话去获取用户数据，
由于用户id在两表间是通用的，所以可以在Service中判断其是否一致，而后决定是否放行，我们通过CommonReturnType中返回的数据确定是否成功，
而后才能决定是否跳转。

用户注册:
我们需要知道的是：可以在数据库层中将字段属性设置为unique而决定注册手机号是否重复。
前端传入一个手机号，而后通过随机生成的验证码和手机号通过HttpServletRequest中的方法绑定，发送验证码成功后跳转到注册界面。
注册界面中:首先依次填入用户的各种数据，取得HttpServletRequest中的绑定数据去和输入的验证码做校验，校验成功后给传输层对象赋值，
传输层对象又给数据库对象赋值，而后调用方法将数据存入数据库中。
（密码加密才赋值、加入validator进行统一错误校验，可大大减少代码量。）

商品模块：
首先我们需要定义的商品可以携带多类信息，但是由于库存等数据不方便直接放于一表中，所以分表存储。这部分其实和用户模块的差别并不是很大。

创建商品：
首先是创建商品，这部分其实和用户注册的结构相像，就是将我们传输层的数据转换为其他格式存入数据库，而又转换为可观看的模式给我们的前端查看。
（为什么View层和Model层的格式一样却依旧要分开写呢？
在一开始做数据处理的时候两者可能类型大致一样，但是在后期由于前端需求或者交互，我们需要在View层中定义更多的字段信息去保证需求，
所以分开定义有利于我们分层和代码的简洁。）

商品浏览：
这里其实是比较老生常谈的信息。通过List方法去dao层定义方法并调试，之后通过jdk1.8的stream()方法将Model的List转换为View层所需要的List。
而后经过点击跳转到商品详情页面。

商品详情：
该部分其实和获取用户并没有太大的差别，都是获取信息之类的方法。

交易模块：
该模块所考虑的信息比较多，首先我们需要知道的是下单请求通常所需要包含的信息：用户参数、商品参数。
用户参数在登录时的信息已经存放在Session域中了，所以该部分可以快速获取，而商品id可以直接通过ajax获取，购买数量通过自身定义。
交易可分为以下几步：
1.校验下单状态，用户是否存在，用户是否合法，购买数量是否正确等
2.校验活动信息 该商品是否处于活动中
3.下单锁定商品 付款则减少库存并增加销量
4.付款之后订单正式入库
5.生成相对应的交易流水号并生成一张对应的交易流水号表
6.返回数据到前端。


